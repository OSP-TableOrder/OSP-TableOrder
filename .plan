# Firestore 데이터 구조 정규화 계획

## 목표: 정규화된(Normalized) 아키텍처로 이행

정현재 비정규화된 데이터(메뉴 전체 정보가 Receipt에 내장)를 정규화하여:
- 메뉴 정보 중복 제거
- 메뉴 마스터 데이터의 단일 정보 소스(Single Source of Truth) 확보
- 쿼리 성능 및 데이터 일관성 개선

## 현재 상태 분석

### 문제점
1. **Orders 컬렉션의 역할 과부하**
   - 기존 Orders: 테이블의 "영수증"(전체 이용 내역) 역할을 담당
   - 동시에 menus 배열에 주문한 메뉴를 누적하면서 "주문 행위" 기록 시도
   - 결과: "어떤 메뉴가 이번에 새로 추가된 주문인지" 알 수 없음

2. **신규 주문 알림 구현 어려움**
   - Admin: hasNewOrder 플래그와 OrderStatus.ordered로 판단 (메뉴 상태 'ORDERED' 확인)
   - 하지만 이는 즉시 알림이 아니라 폴링/로드 시점의 확인일 뿐

3. **CallRequests와 Orders의 느슨한 연결**
   - CallRequests는 현재 receiptId를 저장하지만, 실제로는 Orders(영수증)를 가리킴
   - 구조가 명확하지 않음

### 긍정적 요소
- storeId를 통한 매장별 데이터 분리가 잘 구성됨
- 기본적인 CRUD 연산이 구현되어 있음
- 메뉴 상태 관리 로직이 존재함

## 개선 계획

### 1단계: 정규화된 Firestore 컬렉션 구조

#### A) Receipts 컬렉션 (영수증/청구서)
```
Receipts/{receiptId}
├─ storeId: String
├─ tableId: String
├─ orders: [orderId1, orderId2, ...]  ← Order IDs 배열 (참조)
├─ status: 'unpaid' | 'paid'
├─ totalPrice: number (계산됨 - 선택사항)
├─ createdAt: Timestamp
└─ updatedAt: Timestamp
```

**역할:**
- 테이블의 주문 세션/청구서 관리
- 여러 Order 문서 참조
- 정산 상태 관리

#### B) Orders 컬렉션 (주문 일괄)
```
Orders/{orderId}
├─ receiptId: String (Receipts/{receiptId} 참조)
├─ storeId: String
├─ tableId: String
├─ items: [
│   {
│     menuId: String (Menus/{menuId} 참조) ← 핵심: 메뉴 ID만 저장
│     quantity: int
│     status: 'ordered' | 'cooking' | 'completed' | 'canceled'
│     completedCount: int
│     orderedAt: Timestamp
│     priceAtOrder: number (주문 시점의 메뉴 가격 - 히스토리)
│   }
│ ]
├─ totalPrice: number
├─ createdAt: Timestamp
└─ updatedAt: Timestamp
```

**역할:**
- 고객이 "주문하기"를 누를 때마다 생성
- 메뉴는 ID 참조만 저장 (세부 정보는 Menus에서 조회)
- 주문 시점의 가격 기록 (히스토리 목적)

#### C) Menus 컬렉션 (메뉴 마스터 데이터)
```
Menus/{menuId}
├─ storeId: String
├─ categoryId: String
├─ name: String
├─ description: String
├─ imageUrl: String | null
├─ price: number (현재 가격)
├─ isSoldOut: boolean
├─ isActive: boolean
├─ stock: number (필요시)
├─ createdAt: Timestamp
└─ updatedAt: Timestamp
```

**역할:**
- 메뉴의 단일 정보 소스(Single Source of Truth)
- Orders에서 참조
- 가격 변경 시 새 Orders부터 적용 (과거는 priceAtOrder 사용)

#### D) CallRequests 컬렉션 (기존 유지, receiptId 추가)
```
CallRequests/{callRequestId}
├─ storeId: String
├─ tableId: String
├─ tableName: String
├─ receiptId: String (Receipts/{receiptId} 참조)
├─ message: String
├─ status: 'pending' | 'resolved'
├─ createdAt: Timestamp
└─ updatedAt: Timestamp
```

### 2단계: 데이터 마이그레이션 전략

#### Phase 1: 준비
1. Firestore 데이터 백업
2. Menus 컬렉션 생성 (현재 Receipt.menus[].menu에서 추출)
3. 마이그레이션 스크립트 검증

#### Phase 2: 데이터 변환 (Cloud Functions 또는 앱에서)
```
For each Receipt in Receipts:
  1. Menu 정보 추출 → Menus 컬렉션에 저장 (중복 제거)
  2. Menu ID로 변환된 Order 문서 생성
  3. Receipt.orders 배열 생성 및 업데이트
  4. Receipt.menus 필드 삭제
```

#### Phase 3: 코드 업데이트
1. Models 업데이트
   - Order 모델: menuId 참조 필드 추가
   - Menu 모델: 새로 생성
   - Receipt 모델: orders 배열 필드 추가

2. Repositories 업데이트
   - ReceiptRepository: orders 배열 처리
   - OrderRepository: menuId 참조 처리
   - MenuRepository: 신규 생성

3. Services 업데이트
   - ReceiptService: 기존 유지
   - OrderService: menuId 기반으로 변경
   - MenuService: 신규 생성

4. Providers 업데이트
   - OrderProvider: 메뉴 조회 시 Menus 컬렉션 참조

### 3단계: Firestore Indexes 추가

필요한 인덱스:
```
Receipts: storeId + status + createdAt
Orders: storeId + tableId + status + createdAt
Orders: receiptId (자동 생성되나 명시적으로 설정)
```

### 4단계: 데이터 조회 로직 변경

#### Before (현재)
```
Receipts/{receiptId}
  └─ menus[].menu 에서 메뉴 정보 직접 읽음
```

#### After (정규화)
```
1. Receipts/{receiptId}.orders 배열 조회
2. Orders/{orderId} 배치 조회
3. 각 Order.items[].menuId로 Menus/{menuId} 조회
4. 메뉴 정보와 주문 상태 병합
```

### 5단계: 성능 최적화

#### 배치 조회 최적화
- Future.wait()로 여러 Orders 병렬 조회
- Future.wait()로 여러 Menus 병렬 조회

#### 캐싱 전략
- 메뉴 정보는 변경 빈도 낮음 → 로컬 캐시 고려
- 주문 정보는 실시간성 중요 → 캐시 최소화

## 구현 순서
1. **마이그레이션 계획 수립** (현재)
2. **Menus 컬렉션 생성** ← 가장 중요
3. **Orders 컬렉션 마이그레이션**
4. **Receipts 컬렉션 정리** (menus 필드 제거)
5. **Models 업데이트**
6. **Repositories 업데이트**
7. **Services 업데이트**
8. **Providers 업데이트**
9. **UI 업데이트** (메뉴 조회 로직)
10. **테스트 및 검증**

## 마이그레이션 체크리스트

### Phase 1: 준비
- [ ] Firestore 데이터 백업 생성
- [ ] 마이그레이션 스크립트 작성
- [ ] 테스트 환경에서 검증

### Phase 2: 실행
- [ ] Menus 컬렉션 생성
- [ ] Orders 컬렉션 생성 (기존 데이터에서)
- [ ] Receipts 컬렉션 업데이트
- [ ] 데이터 검증

### Phase 3: 코드 변경
- [ ] Models 업데이트
- [ ] Repositories 수정
- [ ] Services 수정
- [ ] Providers 수정
- [ ] UI 업데이트
- [ ] flutter analyze: No issues

### Phase 4: 배포
- [ ] 테스트 환경 검증
- [ ] 스테이징 배포
- [ ] 프로덕션 배포

## 주요 이점
✅ 메뉴 정보 중복 제거
✅ 메뉴 마스터 데이터의 단일 정보 소스
✅ 과거 주문의 가격 히스토리 보존
✅ 메뉴 변경이 과거 주문에 영향 없음
✅ 쿼리 성능 개선 가능
✅ 데이터 일관성 향상
